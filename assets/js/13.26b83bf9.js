(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{201:function(e,s,a){"use strict";a.r(s);var t=a(3),i=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"architecture"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#architecture"}},[e._v("#")]),e._v(" Architecture")]),e._v(" "),a("h2",{attrs:{id:"sharding-with-kafka-message-offset-stripe-default"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sharding-with-kafka-message-offset-stripe-default"}},[e._v("#")]),e._v(" Sharding with kafka message offset stripe (default)")]),e._v(" "),a("p",[e._v("clickhouse_sinker guarantee:")]),e._v(" "),a("ul",[a("li",[e._v("at-least-once")]),e._v(" "),a("li",[e._v("Duplicated messages (per topic-partition-offset) are routed to the same ClickHouse shard.")])]),e._v(" "),a("p",[e._v("So if you setup ClickHouse properly(ReplacingMergeTree ORDER BY (__kafak_topic, __kafka_partition, __kafka_offset)), you could get exactly-once semantic.")]),e._v(" "),a("p",[e._v("It's hard for clickhouse_sinker to guarantee exactly-once semantic without ReplacingMergeTree. Kafka consumer group load-balance cause duplicated messages if one consumer quit suddenly.")]),e._v(" "),a("p",[e._v("The flow is:")]),e._v(" "),a("ul",[a("li",[e._v("Fetch message via kafka-go or samara, which starts internally an goroutine for each partition.")]),e._v(" "),a("li",[e._v("Parse messages in a global goroutine pool(pool size is customizable), fill the result to a ring according to the message's partition and offset.")]),e._v(" "),a("li",[e._v("Generate a batch if messages in a ring reach a batchSize bondary, or flush timer fire. This ensures offset/batchSize be same for all messages inside a batch.")]),e._v(" "),a("li",[e._v("Write batchs to ClickHouse in a global goroutine pool(pool size is fixed according to number of task and clickhouse shards). Batch is routed according to "),a("code",[e._v("(kafka_offset/roundup(batch_size))%clickhouse_shards")]),e._v(".")])]),e._v(" "),a("h2",{attrs:{id:"sharding-with-custom-key-and-policy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sharding-with-custom-key-and-policy"}},[e._v("#")]),e._v(" Sharding with custom key and policy")]),e._v(" "),a("p",[e._v("clickhouse_sinker guarantee:")]),e._v(" "),a("ul",[a("li",[e._v("at-least-once")]),e._v(" "),a("li",[e._v("Every message is routed to the determined (per "),a("code",[e._v("shardingKey")]),e._v(" and "),a("code",[e._v("shardingPolicy")]),e._v(") ClickHouse shard.")])]),e._v(" "),a("p",[a("code",[e._v("shardingKey")]),e._v(" value is a column name. "),a("code",[e._v("shardingPolicy")]),e._v(" value is "),a("code",[e._v("stripe,<size>")]),e._v(" or "),a("code",[e._v("hash")]),e._v(".\nThe hash function used internally is xxHash64.")]),e._v(" "),a("p",[e._v("The flow is:")]),e._v(" "),a("ul",[a("li",[e._v("Fetch message via kafka-go or samara, which starts internally an goroutine for each partition.")]),e._v(" "),a("li",[e._v("Parse messages in a global goroutine pool(pool size is customizable), fill the result to a ring according to the message's partition and offset.")]),e._v(" "),a("li",[e._v("Shard messages in a ring if reach a batchSize bondary, or flush timer fire. There's one-to-one relationship between shard slots and ClickHouse shards.")]),e._v(" "),a("li",[e._v("Generate batches for all shard slots if messages in one shard slot reach batchSize, or flush timer fire. Those batches form a "),a("code",[e._v("BatchGroup")]),e._v(". The "),a("code",[e._v("before")]),e._v(" relationship could be impossilbe if messages of a partition are distributed to multiple batches. So those batches need to be committed after ALL of them have been written to clickhouse.")]),e._v(" "),a("li",[e._v("Write batchs to ClickHouse in a global goroutine pool(pool size is fixed according to number of task and clickhouse shards).")])]),e._v(" "),a("h1",{attrs:{id:"remote-config-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#remote-config-management"}},[e._v("#")]),e._v(" Remote Config Management")]),e._v(" "),a("p",[e._v("All clickhouse_sinker instances share(fetched from Nacos, Consul, ZK etc.) Config structure:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type Config struct {\n\tKafka      map[string]*KafkaConfig\n\tClickhouse map[string]*ClickHouseConfig\n\tTasks []*TaskConfig\n\tCommon struct {\n\t\t...\n\t\tReplicas          int //on how many sinker instances a task runs\n\t}\n\tAssigns map[string][]string //map instance_name to a list of task_name\n}\ntype TaskConfig struct {\n\t...\n\tReplicas         int    //on how many sinker instances this task runs\n}\n\n")])])]),a("p",[e._v("Each instance can run multiple tasks.\nEach task can be assigned to multiple instances. Each task declares how many instances it needs.")]),e._v(" "),a("h2",{attrs:{id:"the-coordinator-outside-this-project"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-coordinator-outside-this-project"}},[e._v("#")]),e._v(" The coordinator(outside this project)")]),e._v(" "),a("ul",[a("li",[e._v("The coordinator provides API and/or webui to add/delete/modify tasks.")]),e._v(" "),a("li",[e._v("The coordinator watches (do "),a("code",[e._v("service discovery")]),e._v(") instance startup/disappear events, and assign tasks to instances (do "),a("code",[e._v("publish config")]),e._v("). Refers to "),a("code",[e._v("cmd/nacos_publish_config/main.go")]),e._v(" to assign tasks (from local config) via consistent-hash to instances(from CLI).")])]),e._v(" "),a("h2",{attrs:{id:"the-schedule-platform-outside-this-project"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-schedule-platform-outside-this-project"}},[e._v("#")]),e._v(" The schedule platform(outside this project)")]),e._v(" "),a("p",[e._v("The schedule platform start some clickhouse_sinker instances and start another one if a instance fail.")]),e._v(" "),a("h2",{attrs:{id:"clickhouse-sinker"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#clickhouse-sinker"}},[e._v("#")]),e._v(" clickhouse_sinker")]),e._v(" "),a("ul",[a("li",[e._v("Every clickhouse_sinker instance register itself to a service manager (Nacos, Consul, ZK etc.).")]),e._v(" "),a("li",[e._v("clickhouse_sinker watches (do "),a("code",[e._v("get config")]),e._v(") cofig, compare its assignment with the current one, apply changes.")]),e._v(" "),a("li",[e._v("clickhouse_sinker shall try to recover a task in endless loop if the task fail. This ensures the tasks run on an instance match the coordinator assigned.")])])])}),[],!1,null,null,null);s.default=i.exports}}]);